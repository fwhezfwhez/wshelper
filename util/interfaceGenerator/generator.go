package interfaceGenerator

import (
	"bufio"
	"fmt"
	"strings"
)

// doc:
// ** the whole content of base.go should be arg **
// example:
/*
func main(){
rs := ModelToInterface(`
package model

import "time"

type SendOne struct {
	From    string
	To      string
	SendAt  time.Time
	Message string
	Extra   []byte
}

type Reply struct {
	ReplyType  int
	Desc       string
	Tip        string
	Debug      string
	Notice     string
	ReplyValue interface{}
}
   `)
fmt.Println(rs)
}
*/
//
// the interface-generator is used to convert /model/base.go' format models into interfaces in /model/baseI.go.
// since the base.go's models are designed clean, all added new protocol models should format well. these below are some good and bad formats
// model bad formats
// 1. don't use inheritance like
//    type U struct{
//        JSONMarshaller
//    }
// 2. don't use anonymous function like
//    struct{
//    }
// 3. don't put '{' '}' in the same line like
//    struct SendOne struct{}
// 4. don't use tag
//
// GOOD FORMATS:
// type User struct{
// }
// type User struct{
//    Name string
// }
//
func ModelToInterface(in string) string {
	scanner := bufio.NewScanner(strings.NewReader(in))
	var note = fmt.Sprintf("// note: This file is auto-generated by model/base.go. You should not edit this file in any case.\n// The convertion can be executed repeately and the file content will be rewrite by the last time execution. \n")
	var result = note
	//CutAfterN(note, &result, 50)

	var lineTmp = ""
	var meetSpot bool
	for scanner.Scan() {
		oldLine := scanner.Text()
		oldLine = strings.TrimSpace(strings.Trim(oldLine, "\t"))
		if oldLine == "" {
			continue
		}

		// handle struct first line
		if strings.HasPrefix(strings.Trim(oldLine, " "), "type") && strings.Contains(oldLine, "struct") && strings.Contains(oldLine, "{") {
			meetSpot = true
			arr := Split(strings.TrimSpace(oldLine), " ")
			structName := arr[1]
			lineTmp = fmt.Sprintf("type %sI interface{\n", structName)
			result += lineTmp
			continue
		}

		if !meetSpot {
			result += oldLine + "\n"
			continue
		}

		// handle struct last line
		if strings.TrimSpace(oldLine) == "}" {
			lineTmp = "}\n"
			result += lineTmp
			continue
		}
		arr := Split(oldLine, " ")
		fieldName := arr[0]
		typeName := arr[1]
		lineTmp = fmt.Sprintf("    %s() %s\n", strings.Title(fieldName), typeName)
		result += lineTmp
		continue
	}
	return result
}

// greater splitterï¼Œsplit  a,,,,,,,b,,c    to [a,b,c]
func Split(s string, sub string) []string {
	var rs = make([]string, 0, 20)
	tmp := ""
	Split2(s, sub, &tmp, &rs)
	return rs
}

// the detail of Split
func Split2(s string, sub string, tmp *string, rs *[]string) {
	s = strings.Trim(s, sub)
	if !strings.Contains(s, sub) {
		*tmp = s
		*rs = append(*rs, *tmp)
		return
	}
	for i := range s {
		if string(s[i]) == sub {
			*tmp = s[:i]
			*rs = append(*rs, *tmp)
			s = s[i+1:]
			Split2(s, sub, tmp, rs)
			return
		}
	}
}

// incorrect, don't use it
func FormatAnnotationByN(src string, n int) string {
	if len(src) <= n {
		return src
	}
	var spots = make([]int,0,10)
	var spot int
	var offset int
	for i,_ := range src {
		if (i+1) % n == offset%n {
			if len(src) > i+2 && !notWord(string(src[i+1])){
				for j:=i+1;j<len(src);j++ {
					offset ++
					if notWord(string(src[j])) {
						spot = j
						spots = append(spots, spot)
					}
				}
			} else {
				spot = i
				spots = append(spots, spot)
			}
		}
	}
	fmt.Println(spots)
	var rss = make([]string,0, 10)
	var tmp string
	var begin int
	var end int
	for i:=0;i<len(spots)-2;i++{
		begin = spots[i]
		end = spots[i+1]
		if end < begin {
			continue
		}
		fmt.Println(begin,end)
		tmp = string(src[begin:end])
		tmp = strings.TrimSpace(tmp)
		rss = append(rss, tmp)
	}

	return strings.Join(rss, "\n")
}


func notWord(arg string) bool {
	if arg == "." || arg == "," || arg =="\t" || arg ==" "{
		return true
	}
	return false
}
